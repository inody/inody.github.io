<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | inosite</title>
<meta name=keywords content><meta name=description content="Posts - inosite"><meta name=author content><link rel=canonical href=https://inody.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://inody.github.io/elephant.png><link rel=icon type=image/png sizes=16x16 href=https://inody.github.io/elephant.png><link rel=icon type=image/png sizes=32x32 href=https://inody.github.io/elephant.png><link rel=apple-touch-icon href=https://inody.github.io/elephant.png><link rel=mask-icon href=https://inody.github.io/elephant.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://inody.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://inody.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9B4P13HJGR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9B4P13HJGR")}</script><meta property="og:url" content="https://inody.github.io/posts/"><meta property="og:site_name" content="inosite"><meta property="og:title" content="Posts"><meta property="og:description" content="This is my website"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="This is my website"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://inody.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://inody.github.io/ accesskey=h title="🏠  (Alt + H)">🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://inody.github.io/biography title="about me"><span>about me</span></a></li><li><a href=https://inody.github.io/research title=research><span>research</span></a></li><li><a href=https://inody.github.io/publication title=publications><span>publications</span></a></li><li><a href=https://inody.github.io/posts title=posts><span class=active>posts</span></a></li><li><a href=https://inody.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>デルタ関数とは、超関数とは</h2></header><div class=entry-content><p>デルタ関数って結局何なの？ 工学の至る所で現れるデルタ関数。これはよく $$ \delta(t):= \begin{cases} \infty, & t=0\\newline 0, & t\ne 0 \end{cases}, $$ $$ \int_\infty^\infty \delta(x-y)f(y)dy = f(x), $$ $$ \int_\infty^\infty \delta(t)dt = 1 $$ を満たす関数 $\delta$ という風に定義されていますが、「 $t=0$ は測度0なので、その積分は0になるのでは」と考えたことがある人は多いのではないでしょうか。 実はこの定義は不正確なものであり、「超関数」という概念によって、正確に定義することができます。
超関数の定義 ある数値を入力するとある数値を出力する装置のことを、関数といいます。 これに対して、ある関数を入力するとある複素数を出力するような装置のことを、汎関数といいます。 汎関数 $F$ に関数 $\phi$ を入力した時の出力値を $F[\phi]$ 、または $\langle F, \phi \rangle$ と書きます。以下では後者の書き方を用います。
全区間で無限回微分可能で、関数値が0でないところが有界区間に限られるような関数の全体からなる集合を $\mathcal D$ とします。 $\mathcal D$ 上に属する関数 $\phi$ をテスト関数と呼びます。 また、 $\mathcal D$ を定義域とする汎関数を $\mathcal D$ 上の汎関数と呼びます。
ここで、シュワルツの超関数は、つぎのように定義されます。
汎関数 $F$ が、
$\langle F, \phi_1 + \phi_2\rangle = \langle F, \phi_1\rangle + \langle F, \phi_2\rangle,$ $\langle F, c\phi\rangle = c\langle F, \phi\rangle\ (c\in\mathbb K),$ テスト関数の列 ${\phi_n}$ が $n\to\infty$ で $\phi$ に収束する時、 $\langle F, \phi_n\rangle$ もまた $\langle F, \phi\rangle$ に収束する を満たすとき、 $F$を超関数という。
...</p></div><footer class=entry-footer><span title='2017-10-15 00:00:00 +0900 JST'>October 15, 2017</span></footer><a class=entry-link aria-label="post link to デルタ関数とは、超関数とは" href=https://inody.github.io/posts/generalized-function/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>カーネル型機械学習入門</h2></header><div class=entry-content><p>$d$個の数値を並べた変数$\mathbf{x}=(x_1,x_2,\ldots,x_d)^{\mathrm T}$から、 $y$という変数を推定する多変量の回帰問題を考えます。 サンプルデータは$n$組あるとし、$i$番目のサンプルを$\mathbf{x}^{(i)}, y^{(i)}$と書くことにします。
線形モデル まず、カーネルを使わない線形モデル
$$y = \mathbf w^\mathrm T \mathbf x$$
を考えましょう。これは、データを原点を通る直線で当てはめることを意味します。 直線からのズレに対して、損失を
$$r(y,\mathbf{x};\mathbf{w}) = (y-\mathbf w^\mathrm T \mathbf x)^2$$
として定義し、全てのサンプルの総和
$$R(\mathbf{w}) = \sum_{j=1}^n r(y,\mathbf{x};\mathbf{w})$$
を考えます。$R(\mathbf{w})$は
$$\mathbf y := \left( \begin{array}{ccc} y^{(1)}\newline y^{(2)}\newline \vdots\newline y^{(n)} \end{array} \right) $$ $$X := \left( \begin{array}{ccc} x_1^{(1)} & \cdots & x_d^{(1)}\newline x_1^{(2)} & \cdots & x_d^{(2)}\newline \vdots& & \vdots\newline x_1^{(n)} & \cdots & x_d^{(n)} \end{array} \right) $$
を用いて、
$$R(\mathbf{w})=(\mathbf y-X\mathbf w)^\mathrm T(\mathbf y-X\mathbf w)$$
...</p></div><footer class=entry-footer><span title='2017-07-23 00:00:00 +0900 JST'>July 23, 2017</span></footer><a class=entry-link aria-label="post link to カーネル型機械学習入門" href=https://inody.github.io/posts/kernel-machine-learning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>日経平均株価をLSTMを用いて予測してみた</h2></header><div class=entry-content><p>概要 今流行りの深層学習で日経平均株価を予想してみました。 結論から言えば、全く予想できず、惨敗でした。
LSTMとは LSTMとはリカレントニューラルネットワーク（RNN）と呼ばれる機械学習手法の一つです。 RNNを用いることで、現在と過去一定時間の時系列データから、未来のデータを予測することができます。 また、RNNを改良したLSTMでは、長期のトレンドが反映されやすいとされています。
詳しくはこちらのサイトをご覧ください。
学習データとかモデルとか こちらのサイトから、過去4ヶ月の1時間足のデータをダウンロードし、学習データとして用いました。 モデルの隠れ層のユニット数は100、過去20時間の株価から1時間先の株価を予測するモデルを用いました。学習方法はAdamを用いました。
実装 Keras(TensorFlow)を用いて実装しました。初めて使ったんですが、短く書けて便利ですね。以下、ソースコードを載せておきます。
# coding: utf-8 import numpy as np from keras.models import Sequential from keras.layers import Dense, Activation from keras.layers.recurrent import LSTM from keras.optimizers import Adam from keras.initializers import TruncatedNormal from keras.callbacks import EarlyStopping from sklearn.model_selection import train_test_split import matplotlib.pyplot as plt import seaborn import pandas as pd df = pd.read_csv('~/deep_learning/csv/nikkei4_7.csv') x = df['始値'] / df['始値'].max() f = list(x) length_of_sequences = len(f) maxlen = 20 data = [] target = [] for i in range(0, length_of_sequences - maxlen): data.append(f[i:i+maxlen]) target.append(f[i+maxlen]) X = np.array(data).reshape(len(data), maxlen, 1) Y = np.array(target).reshape(len(data), 1) N_train = int(len(data)*0.9) N_validation = len(data) - N_train X_train, X_validation, Y_train, Y_validation = \ train_test_split(X, Y, test_size=N_validation) n_in = len(X[0][0]) n_hidden = 100 n_out = len(Y[0]) weight_hidden = TruncatedNormal(stddev=np.sqrt(1/n_hidden)) weight_out = TruncatedNormal(stddev=np.sqrt(1/n_out)) model = Sequential() model.add(LSTM(n_hidden, init=weight_hidden, input_shape=(maxlen, n_out))) model.add(Dense(n_out, init=weight_out)) model.add(Activation('linear')) optimizer = Adam(lr=0.001, beta_1=0.9, beta_2=0.999) model.compile(loss='mean_squared_error', optimizer=optimizer) epochs = 500 batch_size = 10 early_stopping = \ EarlyStopping(monitor='val_loss', patience=10, verbose=1) hist = model.fit(X_train, Y_train, epochs=epochs, batch_size=batch_size, validation_data=(X_validation, Y_validation), callbacks=[early_stopping]) ## predict 1 step future original = [f[i] for i in range(length_of_sequences)] predicted = [None for i in range(maxlen)] for i in range(1, length_of_sequences - maxlen): Z = X[:i] z_ = Z[-1:] y = model.predict(z_) predicted.append(y[0][0]) plt.figure() plt.plot(original, label="original") plt.plot(predicted, label="predicted") plt.legend() plt.xlabel("step") plt.ylabel("price") plt.show() 結果 上のスクリプトを走らせた結果、つぎの結果が得られました。 一見予測できているように見えます。 しかしながら、ズームしてみると、 このように、実際の動きから遅れていることがわかります。 これでは全く意味がありません。 世の中そんなに甘い話はありませんね。
...</p></div><footer class=entry-footer><span title='2017-07-16 00:00:00 +0900 JST'>July 16, 2017</span></footer><a class=entry-link aria-label="post link to 日経平均株価をLSTMを用いて予測してみた" href=https://inody.github.io/posts/lstm-market/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一色正彦ら著『理系のための交渉学入門』を読みました</h2></header><div class=entry-content><p>交渉というと、心理的駆け引きがものをいう、才能が支配する活動であり、自分のような口下手には縁遠いものだという印象がありました。 しかしながら、本書は「交渉には理論があり、後天的に交渉力は獲得できる」という立場のもと、その基礎的な理論を紹介しています。
もっとも基礎的なこととして、交渉は準備が8割であり、始める前につぎの3つを決めるべきだとあります。
ミッション（Mission）：交渉の軸となるもの。 ゾーパ（ZOPA, Zone Of Possible Agreement）最高と最低の2段構えの幅のある目標 バトナ（Best Alternative To Negotiated Agreement）：ミッションを達成できなかったときの代替選択肢。 また、これらを定める前後で、違いを取り巻く状況を把握するために、マップやツリーを書いてみることは、状況を俯瞰したり、問題点を分解したりする際に役立ちます。
交渉中、お互いの考えを把握するために、ブレイン・ストーミング、いわゆるブレストを行うことも非常に有効だとあります。 ただし、ブレストをする上で絶対に守らなければいけないこととして、
はじめに最後に行うことを決めておく アイデアの批判と評価を混在しない 取りうる選択肢を決める際は、軸を決めて比較し、決定する などがあります。
相手との長期的な関係を求めている場合、下手な交渉テクニックを使うことはあまり得策ではないそうです。 このような交渉テクニックとして
フットインザドア：最初に取るに足らないような要求を提示し、小さなイエスを引き出す、その上で徐々に要求をエスカレートさせていく。 ドアインザフェイス：最初に課題な要求を出して相手にノーと言わせ、条件を下げて本来の要求を出す。 ニブリング：一旦合意に達した後、相手の気が緩んだところに追加条件を提示し、受諾させる。 タイムプレッシャー：アイスブレイクの時に相手の交通手段などを聞き出し、デットラインを把握。その上で交渉の最終条件の提示をそのデットライン近くまで遅らせ、プレッシャーを与える。 などがあります。
最後に、交渉を成功させる秘訣は、決して感情的にならず、なるべく第三者の視点から交渉に臨むことです。 これから社会人になる身として、学ぶべきことが多く書かれていた本書は、ぜひ手元に置いておきたい本だと感じました。</p></div><footer class=entry-footer><span title='2017-01-29 00:00:00 +0900 JST'>January 29, 2017</span></footer><a class=entry-link aria-label="post link to 一色正彦ら著『理系のための交渉学入門』を読みました" href=https://inody.github.io/posts/read-isshiki/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（3）</h2></header><div class=entry-content><p>GPIFによるデータ GPIF（年金積立金管理運用独立行政法人）は、厚生年金と国民年金の積立金の管理・運用を行っている団体です。 この団体は、定期的に各金融商品のリスクとリターン、相関係数について評価しており、それらをもとに積立金の運用のためのポートフォリオを決定しています。 ただし、ここでの金融商品とは、会社ごとの株式などではなく、TOPIXや日経225などに代表される、株式市場の株価指数を指すこMとに注意してください。
GPIFは、金融商品を
国内債券 国内株式 海外債権 海外株式 の4つに分けて評価をおこなっており、それぞれのリターン、リスク、相関係数の値は2016年公開のこちらの資料によると、つぎのようになっています。
リターン（リスクプレミアムなし）
国内債券 国内株式 海外債権 海外株式 2.3 5.9 3.6 6.3 リスク
国内債券 国内株式 海外債権 海外株式 4.2 25.23 11.82 26.76 相関係数
国内債券 国内株式 海外債権 海外株式 国内債券 1.000 -0.230 -0.040 -0.090 国内株式 -0.230 1.000 0.060 0.660 海外債権 -0.040 0.060 1.000 0.550 海外株式 -0.090 0.660 0.550 1.000 今回はこれらの金融商品に加えて、「定期預金」も考慮したポートフォリオを最適化したいと思います。 ここで、定期預金のリターンは0.1、リスクは0、他の金融商品との相関係数は全て0としました。 いくつかの資料によれば、ポートフォリオを最適化するにあたって、リスク資産と無リスク資産は分けて考えるのが定石のようです。 しかしながら自分には「無リスク資産をリスク0のリスク資産としてみなす」ことが、何故まずいことなのかよく理解できなかったので、今回は「定期預金」もポートフォリオに加入してみた次第です。 このあたりに詳しい方がおられましたら、ぜひご教授ください……
CVXOPTを用いた最適化 さて、以上のデータを用いて前回紹介した2次計画問題を解くために、Pythonでスクリプトを作成しました。 作成したスクリプトの中では、CVXOPTというソルバー（問題を自動で解いてくれるツール）を用いています。 CVXOPTの使い方は、こちらの記事が参考になります。
ソースコード import numpy import cvxopt from cvxopt import matrix import matplotlib.pyplot as plt mu = numpy.array([[2.3,5.9,3.6,6.3,0.1]]) Sigma = numpy.diag([4.2,25.23,11.82,26.76,0]) R = numpy.array([[1.000,-0.230,-0.040,-0.090,0.000], [-0.230,1.000,0.060,0.660,0.000], [-0.040,0.060,1.000,0.550,0.000], [-0.090,0.660,0.550,1.000,0.000], [0.000,0.000,0.000,0.000,1.000]]) Cov = Sigma@R@Sigma print(numpy.linalg.matrix_rank(Cov)) P = matrix(Cov) q = matrix(numpy.zeros((5,1))) Id = numpy.identity(5) G = matrix(-numpy.concatenate((Id,mu), axis=0)) A = matrix(numpy.ones((1,5))) b = matrix(100*numpy.ones((1,1))) Return_bound = numpy.linspace(0,6.7,50) Return = numpy.array([]) Risk = numpy.array([]) Allocations = numpy.array([]) for re_bound in Return_bound: h = matrix(numpy.array([0.0,0.0,0.0,0.0,0.0,-re_bound*100])) sol = cvxopt.solvers.qp(P,q,G,h,A,b) Sol = sol["x"] Allocations = numpy.append(Allocations,Sol) re = Sol.T@mu.T/100 Return = numpy.append(Return,re) ri = (Sol.T@Cov@Sol/10000)**0.5 Risk = numpy.append(Risk,ri) print(Risk) print(Return) fig = plt.figure() plt.plot(Risk,Return) plt.xlabel("予想リスク（標準偏差）") plt.ylabel("期待リターン [%]") plt.show() Allocations = Allocations.reshape(Return_bound.size,5) Allocations = Allocations.T fig = plt.figure() wd = 5/Return.size p1 = plt.bar(Return, Allocations[0], width = wd, color = "red", label = "国内債権") p2 = plt.bar(Return, Allocations[1], width = wd, bottom=Allocations[0], color = "orange", label = "国内株式") p3 = plt.bar(Return, Allocations[2], width = wd, bottom=sum(Allocations[0:2,:]), color = "yellow", label = "海外債権") p4 = plt.bar(Return, Allocations[3], width = wd, bottom=sum(Allocations[0:3,:]), color = "green", label = "海外株式") p5 = plt.bar(Return, Allocations[4], width = wd, bottom=sum(Allocations[0:4,:]), color = "blue", label = "預金") plt.legend() plt.xlabel("期待リターン [%]") plt.ylabel("資産配分 [%]") plt.xlim([0.1,6.7]) plt.ylim([0,100]) plt.show() plt.close('all') 実行結果 まず、期待リターンに対しての最小リスクを示した図を示します。 「ハイリスク・ハイリターンの原則」に従い、リターンに対してリスクが単調に増加していることがわかります。
...</p></div><footer class=entry-footer><span title='2017-01-09 00:00:00 +0900 JST'>January 9, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（3）" href=https://inody.github.io/posts/portfolio3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（2）</h2></header><div class=entry-content><p>ポートフォリオ最適化 複数の金融商品の組み合わせのことを「ポートフォリオ」といいます。 あなたはAとBを購入する際、そのポートフォリオを調節することで、リスクをできるだけ小さくしながら、リターンをできるだけ大きくしようと思っています。 けれども、「ハイリスクハイリターンの原則」により、それらを限りなく小さくすることはできません。 しかしながら、あなたがもし「望ましいリターン」を決めたときに、「そのリターンを達成し、かつ最もリスクを小さくするポートフォリオ」を求めることは可能です。 このことを「ポートフォリオ最適化」といいます。
この問題を数学的に記述しましょう。 $n$個の金融商品を考えます。 それぞれの商品には$1,\ldots,n$とラベルが振られているとします。 それぞれの商品のリターンを$\mu_1,\ldots,\mu_n$とします。 それぞれの商品のリスクを$\sigma_1,\ldots,\sigma_n$とし、それらを対角に並べたものを$\Sigma$とします。 つまり $$ \Sigma = \begin{bmatrix} \sigma_1 & \cdots & 0\ \vdots & \ddots & \vdots\ 0 & \cdots & \sigma_n \end{bmatrix} $$ です。 商品$i$と$j$の間の相関係数を$r_{ij}$とし、それらを縱橫にならべたものを$R$としましょう。 つまり $$ R = \begin{bmatrix} r_{11} & \cdots & r_{1n}\ \vdots & \ddots & \vdots\ r_{n1} & \cdots & r_{nn} \end{bmatrix} $$ です。
それぞれの商品の購入割合（つまりポートフォリオ）を$w_1,\ldots,w_n$とし、これらを縦に並べたものを$w$とします。 あなたはポートフォリオ$w$を決めることで期待リターン$\nu$を達成したいとしましょう。 このとき、ポートフォリオ最適化問題はつぎのように定式化できます。
最小化すべき目的関数は $$ w^\mathrm{T}\Sigma R \Sigma w\ $$ です。これは全体のリスクを表します。
また、制約条件は $$ w_i \ge 0 \ \forall i = 1, \ldots, n,\ \sum_{i} w_i = 1,\ \sum_{i} w_i\mu_i \ge \nu $$ です。 一つめの不等式は、かく商品の購入割合が正の値であることを表し、2つめの等式は、購入割合の合計が1であることを表します。 また最後の不等式は、全体のリターンが期待リターン$\nu$を上回ることを意味します。
...</p></div><footer class=entry-footer><span title='2017-01-08 00:00:00 +0900 JST'>January 8, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（2）" href=https://inody.github.io/posts/portfolio2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（1）</h2></header><div class=entry-content><p>なぜ分散投資が有効なのか ここに2つの金融商品があったとしましょう。 それぞれの金融商品は「リスク」と「リターン」という特徴量を持っているとします。 リスクは将来予想される値動きの幅を表し、リターンは将来予想される価値の上昇率を表します。 確率の言葉を使うと、リスクは標準偏差、リターンは平均に対応しています。
経済学の言葉に、「ハイリスクハイリターンの原則」というものがあります。 これは、ローリスクかつハイリターンな商品はあり得ないということを表すものです。 例えば、銀行の定期預金などはローリスクである代わりに、リターンも小さくなります。 一方で、株式などはハイリターンが期待できますが、値動きが読めない分ハイリスクであると言えます。
また、2つの金融商品のペアは、「相関係数」という特徴量を持っているとします。 これは、2つの金融商品がどの程度連動して値動きするかを表します。 例えば相関係数が正の値なら、片方の商品が値上がりしたとき、もう片方の商品も値上がりすることが多いことを意味し、相関係数が負の値なら、片方の商品が値上がりしたとき、もう片方の商品は値下がりすることが多いことを意味します。
投資の世界には「卵は１つのカゴに盛るな」という言葉があります。 これは、金融商品を分散して買うことで、リターンを維持しつつ、トータルのリスクを減らすことを推奨する言葉です。
例えば今、2つの金融商品の片方をA、もう片方をBとしましょう。 Aのリターンは5、リスクは10であるとします。 またBのリターンは10、リスクは20であるとします。 さらに、AとBの相関係数は-0.5であるとします。
ここで、片方の金融商品を買ったときと、両方を分散して買ったときの、「リターン/リスク」を求めてみましょう。 この値は、リスクに対してリターンがどれだけ大きいかを示すもので、大きいほどお買い得ということを意味します。
まず、片方の金融商品を買ったとき、両金融商品とも、リターン/リスクは0.5です。
つぎに、AとBを半分ずつ購入したときのリターンとリスクを求めてみましょう。 ここでAとBそれぞれのリターンとリスクが$\mu_A, \mu_B, \sigma_A, \sigma_B$、相関係数が$r_{AB}$であるとし、また二つの商品を$w_A:w_B$の割合で購入したとき、合計のリターン$\mu$とリスク$\sigma$は $$ \mu = w_A \mu_A + w_B \mu_B, $$ $$ \sigma = \sqrt{ (w_A \sigma_A)^2 + 2(w_A w_B r_{AB}\sigma_A\sigma_B) + (w_B \sigma_B)^2 } $$ として求められます。 このことを用いると、分散投資したときのリターンは $$ 0.5\times 5 + 0.5\times 10 = 7.5 $$ となり、リスクは $$ \sqrt{ (0.5\times 10)^2 + 2(0.5\times 0.5\times (-0.5)\times 10\times 20) + (0.5\times 20)^2 } = 8.660 $$ となることがわかります。
...</p></div><footer class=entry-footer><span title='2017-01-05 00:00:00 +0900 JST'>January 5, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（1）" href=https://inody.github.io/posts/portfolio1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>資格取得と人生設計</h2></header><div class=entry-content><p>簿記3級に合格してから、ファイナンシャルプランニング技能検定3級の勉強を進めています。
はじめは「社会に出るにあたって資格の一つや二つ取ったほうがいいだろう」と気軽な気持ちで始めた資格勉強ですが、簿記の合格を契機にその楽しさに目覚めてしまいました。 なんというか、やればやるだけ強くなれるところがRPGと似ていて癖になります。 また、TOEICなどのスコア式の資格と違い、受かるか落ちるかのどちらかである点も、ゲーム性を上げているように思います。
また一度ハマってしまったからには、より上位の資格にも手を出したくなります。 これらの資格は2級以上でないと転職などに役立たないと聞きますし、FP3級の受験が終わったら受けてみようかと検討中です。
一方で、資格の取得自体を目的化してしまうのは危ないとも感じています。 有限の時間の中で、いかに自分のキャリアの可能性を広げ、深化させるかが最も大切であり、資格取得はそのための手段にすぎません。
自分の場合、研究職としてのメインキャリアを歩みつつ、できれば研究された技術の知財化や商品化などにも携わりたいと思っています。 特に知財には興味があるので、知的財産管理技能士や弁理士の資格をとることは大いに検討すべきです。
さらに欲を言えば、資格に限らず、プログラミングや数学の勉強も今まで以上に進めていきたいです。 特にWebサービスをスクラッチから実装したことがないので、ぜひ挑戦してみたいです。
資格にせよ勉強にせよ、あまり手広くやると時間の無駄に終わることは明らかです。 これを機に一度ロードマップを作ってみるのもよいかもしれません。</p></div><footer class=entry-footer><span title='2016-12-26 00:00:00 +0900 JST'>December 26, 2016</span></footer><a class=entry-link aria-label="post link to 資格取得と人生設計" href=https://inody.github.io/posts/license-life/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>簿記3級に受かりました</h2></header><div class=entry-content><p>就職を春に控え、一般常識で欠けている知識を補うために受験した簿記検定3級。 本番で解答用紙の下書きを消し忘れるという手痛いミスをしてしまいましたが、本日結果を確認すると、しっかり点が加算されていました。 参考書として使ったのは、TAC出版のスッキリわかる 日商簿記3級 第7版 [テキスト&問題集]です。 全体的にコンパクトにまとまっており、無駄なく勉強することができました。
つぎはファイナンシャルプランナー検定を受験したいと思います。
スッキリわかる 日商簿記3級 第7版 [テキスト&問題集] (スッキリわかるシリーズ)posted with amazlet at 16.12.06滝澤 ななみ TAC出版 (2016-02-26)
売り上げランキング: 292
Amazon.co.jpで詳細を見る</p></div><footer class=entry-footer><span title='2016-12-06 00:00:00 +0900 JST'>December 6, 2016</span></footer><a class=entry-link aria-label="post link to 簿記3級に受かりました" href=https://inody.github.io/posts/bookkeeping/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LaTeXで図を作成するときにおすすめの方法</h2></header><div class=entry-content><p>研究者の皆さんは，論文を作成するときにIllustratorなどのベクターイメージ編集ソフトを使っていることと存じます． しかしながら，こうしたソフトは一般に有償であり，学生には手が届かないもの． 中にはInkscapeなどのフリーソフトもあるため，そちらを使っている方もいるかもしれません（僕も少し前までこの方法でした）． 今回僕が紹介する手法は，皆さんおなじみのPowerPointやKeynoteなどのプレゼンテーションソフトを使う方法です．
本手法には，
ほとんどどのPCにもビルドインされているプレゼンソフトを使って作図できる（もちろんベクター画像として） 作成した図をそのままプレゼンの素材として流用できる プレゼンソフトの拡張機能を用いて，LaTeXコードで書かれた数式を自由に挿入・変更できる などのメリットがあります．
さて，本題の方法ですが，至ってシンプルです． 今回はPowerPointで説明します．
PowerPointを起動し，最もシンプルな白背景のテンプレートから新規ファイルを作成します
「デザイン」タブの「スライドのサイズ」から，スライドの縦横比を描きたい図に合わせて望ましいものに変更します
白紙のスライドに，図形ツールなどを使って図を作成します
新しい図は，スライドを改めて作成します
図を全て描き終わったら，「ファイル」からPDFとしてエクスポートします
LaTeXのソースコードで図を読み込むとき
\begin{figure}[t] \centering \includegraphics[page=1,width=60mm]{figure.pdf} \caption{An example. } \end{figure}
というように，page=のオプションを用いることで，表示したい図に対応するページ番号を指定します
LaTeXコードをコンパイルします
…という感じです．
この方法ですと，作成した図を一つのPDFファイルにまとめることができ，ディレクトリがすっきりするのも嬉しいポイントです． ただ，論文に挿入する図ごとに縦横比が大きく異なる際は，別の.pptxファイルを用意しなければいけませんので，注意が必要です．
また，PowerPointの場合，IquanaTeXというマクロを使えば，任意のLaTeXコードをベクター画像として生成・編集できますし，Keynoteの場合，MacTeXに最初から付属しているLaTeXitを用いれば自由に数式を挿入できます．
また，もしMatlabの図を使いたい場合，Matlabのプロットが表示されているウィンドウから「編集」→「Figureのコピー」を選んで，そのまま貼り付ければちゃんとベクター画像として処理してくれます．
この方法を編み出してから，めんどくさい作図にかかる時間を短縮することができるようになりました． 読者の皆さんにも自信をもっておすすめします．</p></div><footer class=entry-footer><span title='2016-09-30 00:00:00 +0900 JST'>September 30, 2016</span></footer><a class=entry-link aria-label="post link to LaTeXで図を作成するときにおすすめの方法" href=https://inody.github.io/posts/latex-figure/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://inody.github.io/posts/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://inody.github.io/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://inody.github.io/>inosite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>