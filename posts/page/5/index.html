<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | inosite</title><meta name=keywords content><meta name=description content="Posts - inosite"><meta name=author content><link rel=canonical href=https://inody.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://inody.github.io/elephant.png><link rel=icon type=image/png sizes=16x16 href=https://inody.github.io/elephant.png><link rel=icon type=image/png sizes=32x32 href=https://inody.github.io/elephant.png><link rel=apple-touch-icon href=https://inody.github.io/elephant.png><link rel=mask-icon href=https://inody.github.io/elephant.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://inody.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://inody.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9B4P13HJGR"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9B4P13HJGR")}</script><meta property="og:url" content="https://inody.github.io/posts/"><meta property="og:site_name" content="inosite"><meta property="og:title" content="Posts"><meta property="og:description" content="This is my website"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="This is my website"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://inody.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://inody.github.io/ accesskey=h title="🏠  (Alt + H)">🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://inody.github.io/biography title=biography><span>biography</span></a></li><li><a href=https://inody.github.io/publication title=publications><span>publications</span></a></li><li><a href=https://inody.github.io/posts title=blog><span class=active>blog</span></a></li><li><a href=https://inody.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>カーネル型機械学習入門</h2></header><div class=entry-content><p>$d$個の数値を並べた変数$\mathbf{x}=(x_1,x_2,\ldots,x_d)^{\mathrm T}$から、 $y$という変数を推定する多変量の回帰問題を考えます。 サンプルデータは$n$組あるとし、$i$番目のサンプルを$\mathbf{x}^{(i)}, y^{(i)}$と書くことにします。
線形モデル まず、カーネルを使わない線形モデル
$$y = \mathbf w^\mathrm T \mathbf x$$
を考えましょう。これは、データを原点を通る直線で当てはめることを意味します。 直線からのズレに対して、損失を
$$r(y,\mathbf{x};\mathbf{w}) = (y-\mathbf w^\mathrm T \mathbf x)^2$$
として定義し、全てのサンプルの総和
$$R(\mathbf{w}) = \sum_{j=1}^n r(y,\mathbf{x};\mathbf{w})$$
を考えます。$R(\mathbf{w})$は
$$\mathbf y := \left( \begin{array}{ccc} y^{(1)}\newline y^{(2)}\newline \vdots\newline y^{(n)} \end{array} \right) $$ $$X := \left( \begin{array}{ccc} x_1^{(1)} & \cdots & x_d^{(1)}\newline x_1^{(2)} & \cdots & x_d^{(2)}\newline \vdots& & \vdots\newline x_1^{(n)} & \cdots & x_d^{(n)} \end{array} \right) $$
を用いて、
$$R(\mathbf{w})=(\mathbf y-X\mathbf w)^\mathrm T(\mathbf y-X\mathbf w)$$
...</p></div><footer class=entry-footer><span title='2017-07-23 00:00:00 +0900 +0900'>July 23, 2017</span></footer><a class=entry-link aria-label="post link to カーネル型機械学習入門" href=https://inody.github.io/posts/kernel-machine-learning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>日経平均株価をLSTMを用いて予測してみた</h2></header><div class=entry-content><p>概要 今流行りの深層学習で日経平均株価を予想してみました。 結論から言えば、全く予想できず、惨敗でした。
LSTMとは LSTMとはリカレントニューラルネットワーク（RNN）と呼ばれる機械学習手法の一つです。 RNNを用いることで、現在と過去一定時間の時系列データから、未来のデータを予測することができます。 また、RNNを改良したLSTMでは、長期のトレンドが反映されやすいとされています。
詳しくはこちらのサイトをご覧ください。
学習データとかモデルとか こちらのサイトから、過去4ヶ月の1時間足のデータをダウンロードし、学習データとして用いました。 モデルの隠れ層のユニット数は100、過去20時間の株価から1時間先の株価を予測するモデルを用いました。学習方法はAdamを用いました。
実装 Keras(TensorFlow)を用いて実装しました。初めて使ったんですが、短く書けて便利ですね。以下、ソースコードを載せておきます。
# coding: utf-8 import numpy as np from keras.models import Sequential from keras.layers import Dense, Activation from keras.layers.recurrent import LSTM from keras.optimizers import Adam from keras.initializers import TruncatedNormal from keras.callbacks import EarlyStopping from sklearn.model_selection import train_test_split import matplotlib.pyplot as plt import seaborn import pandas as pd df = pd.read_csv('~/deep_learning/csv/nikkei4_7.csv') x = df['始値'] / df['始値'].max() f = list(x) length_of_sequences = len(f) maxlen = 20 data = [] target = [] for i in range(0, length_of_sequences - maxlen): data.append(f[i:i+maxlen]) target.append(f[i+maxlen]) X = np.array(data).reshape(len(data), maxlen, 1) Y = np.array(target).reshape(len(data), 1) N_train = int(len(data)*0.9) N_validation = len(data) - N_train X_train, X_validation, Y_train, Y_validation = \ train_test_split(X, Y, test_size=N_validation) n_in = len(X[0][0]) n_hidden = 100 n_out = len(Y[0]) weight_hidden = TruncatedNormal(stddev=np.sqrt(1/n_hidden)) weight_out = TruncatedNormal(stddev=np.sqrt(1/n_out)) model = Sequential() model.add(LSTM(n_hidden, init=weight_hidden, input_shape=(maxlen, n_out))) model.add(Dense(n_out, init=weight_out)) model.add(Activation('linear')) optimizer = Adam(lr=0.001, beta_1=0.9, beta_2=0.999) model.compile(loss='mean_squared_error', optimizer=optimizer) epochs = 500 batch_size = 10 early_stopping = \ EarlyStopping(monitor='val_loss', patience=10, verbose=1) hist = model.fit(X_train, Y_train, epochs=epochs, batch_size=batch_size, validation_data=(X_validation, Y_validation), callbacks=[early_stopping]) ## predict 1 step future original = [f[i] for i in range(length_of_sequences)] predicted = [None for i in range(maxlen)] for i in range(1, length_of_sequences - maxlen): Z = X[:i] z_ = Z[-1:] y = model.predict(z_) predicted.append(y[0][0]) plt.figure() plt.plot(original, label="original") plt.plot(predicted, label="predicted") plt.legend() plt.xlabel("step") plt.ylabel("price") plt.show() 結果 上のスクリプトを走らせた結果、つぎの結果が得られました。 一見予測できているように見えます。 しかしながら、ズームしてみると、 このように、実際の動きから遅れていることがわかります。 これでは全く意味がありません。 世の中そんなに甘い話はありませんね。
...</p></div><footer class=entry-footer><span title='2017-07-16 00:00:00 +0900 +0900'>July 16, 2017</span></footer><a class=entry-link aria-label="post link to 日経平均株価をLSTMを用いて予測してみた" href=https://inody.github.io/posts/lstm-market/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一色正彦ら著『理系のための交渉学入門』を読みました</h2></header><div class=entry-content><p>交渉というと、心理的駆け引きがものをいう、才能が支配する活動であり、自分のような口下手には縁遠いものだという印象がありました。 しかしながら、本書は「交渉には理論があり、後天的に交渉力は獲得できる」という立場のもと、その基礎的な理論を紹介しています。
もっとも基礎的なこととして、交渉は準備が8割であり、始める前につぎの3つを決めるべきだとあります。
ミッション（Mission）：交渉の軸となるもの。 ゾーパ（ZOPA, Zone Of Possible Agreement）最高と最低の2段構えの幅のある目標 バトナ（Best Alternative To Negotiated Agreement）：ミッションを達成できなかったときの代替選択肢。 また、これらを定める前後で、違いを取り巻く状況を把握するために、マップやツリーを書いてみることは、状況を俯瞰したり、問題点を分解したりする際に役立ちます。
交渉中、お互いの考えを把握するために、ブレイン・ストーミング、いわゆるブレストを行うことも非常に有効だとあります。 ただし、ブレストをする上で絶対に守らなければいけないこととして、
はじめに最後に行うことを決めておく アイデアの批判と評価を混在しない 取りうる選択肢を決める際は、軸を決めて比較し、決定する などがあります。
相手との長期的な関係を求めている場合、下手な交渉テクニックを使うことはあまり得策ではないそうです。 このような交渉テクニックとして
フットインザドア：最初に取るに足らないような要求を提示し、小さなイエスを引き出す、その上で徐々に要求をエスカレートさせていく。 ドアインザフェイス：最初に課題な要求を出して相手にノーと言わせ、条件を下げて本来の要求を出す。 ニブリング：一旦合意に達した後、相手の気が緩んだところに追加条件を提示し、受諾させる。 タイムプレッシャー：アイスブレイクの時に相手の交通手段などを聞き出し、デットラインを把握。その上で交渉の最終条件の提示をそのデットライン近くまで遅らせ、プレッシャーを与える。 などがあります。
最後に、交渉を成功させる秘訣は、決して感情的にならず、なるべく第三者の視点から交渉に臨むことです。 これから社会人になる身として、学ぶべきことが多く書かれていた本書は、ぜひ手元に置いておきたい本だと感じました。</p></div><footer class=entry-footer><span title='2017-01-29 00:00:00 +0900 +0900'>January 29, 2017</span></footer><a class=entry-link aria-label="post link to 一色正彦ら著『理系のための交渉学入門』を読みました" href=https://inody.github.io/posts/read-isshiki/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（3）</h2></header><div class=entry-content><p>GPIFによるデータ GPIF（年金積立金管理運用独立行政法人）は、厚生年金と国民年金の積立金の管理・運用を行っている団体です。 この団体は、定期的に各金融商品のリスクとリターン、相関係数について評価しており、それらをもとに積立金の運用のためのポートフォリオを決定しています。 ただし、ここでの金融商品とは、会社ごとの株式などではなく、TOPIXや日経225などに代表される、株式市場の株価指数を指すこMとに注意してください。
GPIFは、金融商品を
国内債券 国内株式 海外債権 海外株式 の4つに分けて評価をおこなっており、それぞれのリターン、リスク、相関係数の値は2016年公開のこちらの資料によると、つぎのようになっています。
リターン（リスクプレミアムなし）
国内債券 国内株式 海外債権 海外株式 2.3 5.9 3.6 6.3 リスク
国内債券 国内株式 海外債権 海外株式 4.2 25.23 11.82 26.76 相関係数
国内債券 国内株式 海外債権 海外株式 国内債券 1.000 -0.230 -0.040 -0.090 国内株式 -0.230 1.000 0.060 0.660 海外債権 -0.040 0.060 1.000 0.550 海外株式 -0.090 0.660 0.550 1.000 今回はこれらの金融商品に加えて、「定期預金」も考慮したポートフォリオを最適化したいと思います。 ここで、定期預金のリターンは0.1、リスクは0、他の金融商品との相関係数は全て0としました。 いくつかの資料によれば、ポートフォリオを最適化するにあたって、リスク資産と無リスク資産は分けて考えるのが定石のようです。 しかしながら自分には「無リスク資産をリスク0のリスク資産としてみなす」ことが、何故まずいことなのかよく理解できなかったので、今回は「定期預金」もポートフォリオに加入してみた次第です。 このあたりに詳しい方がおられましたら、ぜひご教授ください……
CVXOPTを用いた最適化 さて、以上のデータを用いて前回紹介した2次計画問題を解くために、Pythonでスクリプトを作成しました。 作成したスクリプトの中では、CVXOPTというソルバー（問題を自動で解いてくれるツール）を用いています。 CVXOPTの使い方は、こちらの記事が参考になります。
ソースコード import numpy import cvxopt from cvxopt import matrix import matplotlib.pyplot as plt mu = numpy.array([[2.3,5.9,3.6,6.3,0.1]]) Sigma = numpy.diag([4.2,25.23,11.82,26.76,0]) R = numpy.array([[1.000,-0.230,-0.040,-0.090,0.000], [-0.230,1.000,0.060,0.660,0.000], [-0.040,0.060,1.000,0.550,0.000], [-0.090,0.660,0.550,1.000,0.000], [0.000,0.000,0.000,0.000,1.000]]) Cov = Sigma@R@Sigma print(numpy.linalg.matrix_rank(Cov)) P = matrix(Cov) q = matrix(numpy.zeros((5,1))) Id = numpy.identity(5) G = matrix(-numpy.concatenate((Id,mu), axis=0)) A = matrix(numpy.ones((1,5))) b = matrix(100*numpy.ones((1,1))) Return_bound = numpy.linspace(0,6.7,50) Return = numpy.array([]) Risk = numpy.array([]) Allocations = numpy.array([]) for re_bound in Return_bound: h = matrix(numpy.array([0.0,0.0,0.0,0.0,0.0,-re_bound*100])) sol = cvxopt.solvers.qp(P,q,G,h,A,b) Sol = sol["x"] Allocations = numpy.append(Allocations,Sol) re = Sol.T@mu.T/100 Return = numpy.append(Return,re) ri = (Sol.T@Cov@Sol/10000)**0.5 Risk = numpy.append(Risk,ri) print(Risk) print(Return) fig = plt.figure() plt.plot(Risk,Return) plt.xlabel("予想リスク（標準偏差）") plt.ylabel("期待リターン [%]") plt.show() Allocations = Allocations.reshape(Return_bound.size,5) Allocations = Allocations.T fig = plt.figure() wd = 5/Return.size p1 = plt.bar(Return, Allocations[0], width = wd, color = "red", label = "国内債権") p2 = plt.bar(Return, Allocations[1], width = wd, bottom=Allocations[0], color = "orange", label = "国内株式") p3 = plt.bar(Return, Allocations[2], width = wd, bottom=sum(Allocations[0:2,:]), color = "yellow", label = "海外債権") p4 = plt.bar(Return, Allocations[3], width = wd, bottom=sum(Allocations[0:3,:]), color = "green", label = "海外株式") p5 = plt.bar(Return, Allocations[4], width = wd, bottom=sum(Allocations[0:4,:]), color = "blue", label = "預金") plt.legend() plt.xlabel("期待リターン [%]") plt.ylabel("資産配分 [%]") plt.xlim([0.1,6.7]) plt.ylim([0,100]) plt.show() plt.close('all') 実行結果 まず、期待リターンに対しての最小リスクを示した図を示します。 「ハイリスク・ハイリターンの原則」に従い、リターンに対してリスクが単調に増加していることがわかります。
...</p></div><footer class=entry-footer><span title='2017-01-09 00:00:00 +0900 +0900'>January 9, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（3）" href=https://inody.github.io/posts/portfolio3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（2）</h2></header><div class=entry-content><p>ポートフォリオ最適化 複数の金融商品の組み合わせのことを「ポートフォリオ」といいます。 あなたはAとBを購入する際、そのポートフォリオを調節することで、リスクをできるだけ小さくしながら、リターンをできるだけ大きくしようと思っています。 けれども、「ハイリスクハイリターンの原則」により、それらを限りなく小さくすることはできません。 しかしながら、あなたがもし「望ましいリターン」を決めたときに、「そのリターンを達成し、かつ最もリスクを小さくするポートフォリオ」を求めることは可能です。 このことを「ポートフォリオ最適化」といいます。
この問題を数学的に記述しましょう。 $n$個の金融商品を考えます。 それぞれの商品には$1,\ldots,n$とラベルが振られているとします。 それぞれの商品のリターンを$\mu_1,\ldots,\mu_n$とします。 それぞれの商品のリスクを$\sigma_1,\ldots,\sigma_n$とし、それらを対角に並べたものを$\Sigma$とします。 つまり $$ \Sigma = \begin{bmatrix} \sigma_1 & \cdots & 0\ \vdots & \ddots & \vdots\ 0 & \cdots & \sigma_n \end{bmatrix} $$ です。 商品$i$と$j$の間の相関係数を$r_{ij}$とし、それらを縱橫にならべたものを$R$としましょう。 つまり $$ R = \begin{bmatrix} r_{11} & \cdots & r_{1n}\ \vdots & \ddots & \vdots\ r_{n1} & \cdots & r_{nn} \end{bmatrix} $$ です。
それぞれの商品の購入割合（つまりポートフォリオ）を$w_1,\ldots,w_n$とし、これらを縦に並べたものを$w$とします。 あなたはポートフォリオ$w$を決めることで期待リターン$\nu$を達成したいとしましょう。 このとき、ポートフォリオ最適化問題はつぎのように定式化できます。
最小化すべき目的関数は $$ w^\mathrm{T}\Sigma R \Sigma w\ $$ です。これは全体のリスクを表します。
また、制約条件は $$ w_i \ge 0 \ \forall i = 1, \ldots, n,\ \sum_{i} w_i = 1,\ \sum_{i} w_i\mu_i \ge \nu $$ です。 一つめの不等式は、かく商品の購入割合が正の値であることを表し、2つめの等式は、購入割合の合計が1であることを表します。 また最後の不等式は、全体のリターンが期待リターン$\nu$を上回ることを意味します。
...</p></div><footer class=entry-footer><span title='2017-01-08 00:00:00 +0900 +0900'>January 8, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（2）" href=https://inody.github.io/posts/portfolio2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（1）</h2></header><div class=entry-content><p>なぜ分散投資が有効なのか ここに2つの金融商品があったとしましょう。 それぞれの金融商品は「リスク」と「リターン」という特徴量を持っているとします。 リスクは将来予想される値動きの幅を表し、リターンは将来予想される価値の上昇率を表します。 確率の言葉を使うと、リスクは標準偏差、リターンは平均に対応しています。
経済学の言葉に、「ハイリスクハイリターンの原則」というものがあります。 これは、ローリスクかつハイリターンな商品はあり得ないということを表すものです。 例えば、銀行の定期預金などはローリスクである代わりに、リターンも小さくなります。 一方で、株式などはハイリターンが期待できますが、値動きが読めない分ハイリスクであると言えます。
また、2つの金融商品のペアは、「相関係数」という特徴量を持っているとします。 これは、2つの金融商品がどの程度連動して値動きするかを表します。 例えば相関係数が正の値なら、片方の商品が値上がりしたとき、もう片方の商品も値上がりすることが多いことを意味し、相関係数が負の値なら、片方の商品が値上がりしたとき、もう片方の商品は値下がりすることが多いことを意味します。
投資の世界には「卵は１つのカゴに盛るな」という言葉があります。 これは、金融商品を分散して買うことで、リターンを維持しつつ、トータルのリスクを減らすことを推奨する言葉です。
例えば今、2つの金融商品の片方をA、もう片方をBとしましょう。 Aのリターンは5、リスクは10であるとします。 またBのリターンは10、リスクは20であるとします。 さらに、AとBの相関係数は-0.5であるとします。
ここで、片方の金融商品を買ったときと、両方を分散して買ったときの、「リターン/リスク」を求めてみましょう。 この値は、リスクに対してリターンがどれだけ大きいかを示すもので、大きいほどお買い得ということを意味します。
まず、片方の金融商品を買ったとき、両金融商品とも、リターン/リスクは0.5です。
つぎに、AとBを半分ずつ購入したときのリターンとリスクを求めてみましょう。 ここでAとBそれぞれのリターンとリスクが$\mu_A, \mu_B, \sigma_A, \sigma_B$、相関係数が$r_{AB}$であるとし、また二つの商品を$w_A:w_B$の割合で購入したとき、合計のリターン$\mu$とリスク$\sigma$は $$ \mu = w_A \mu_A + w_B \mu_B, $$ $$ \sigma = \sqrt{ (w_A \sigma_A)^2 + 2(w_A w_B r_{AB}\sigma_A\sigma_B) + (w_B \sigma_B)^2 } $$ として求められます。 このことを用いると、分散投資したときのリターンは $$ 0.5\times 5 + 0.5\times 10 = 7.5 $$ となり、リスクは $$ \sqrt{ (0.5\times 10)^2 + 2(0.5\times 0.5\times (-0.5)\times 10\times 20) + (0.5\times 20)^2 } = 8.660 $$ となることがわかります。
...</p></div><footer class=entry-footer><span title='2017-01-05 00:00:00 +0900 +0900'>January 5, 2017</span></footer><a class=entry-link aria-label="post link to GPIFのデータをもとに最適ポートフォリオ問題を解いてみた（1）" href=https://inody.github.io/posts/portfolio1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>資格取得と人生設計</h2></header><div class=entry-content><p>簿記3級に合格してから、ファイナンシャルプランニング技能検定3級の勉強を進めています。
はじめは「社会に出るにあたって資格の一つや二つ取ったほうがいいだろう」と気軽な気持ちで始めた資格勉強ですが、簿記の合格を契機にその楽しさに目覚めてしまいました。 なんというか、やればやるだけ強くなれるところがRPGと似ていて癖になります。 また、TOEICなどのスコア式の資格と違い、受かるか落ちるかのどちらかである点も、ゲーム性を上げているように思います。
また一度ハマってしまったからには、より上位の資格にも手を出したくなります。 これらの資格は2級以上でないと転職などに役立たないと聞きますし、FP3級の受験が終わったら受けてみようかと検討中です。
一方で、資格の取得自体を目的化してしまうのは危ないとも感じています。 有限の時間の中で、いかに自分のキャリアの可能性を広げ、深化させるかが最も大切であり、資格取得はそのための手段にすぎません。
自分の場合、研究職としてのメインキャリアを歩みつつ、できれば研究された技術の知財化や商品化などにも携わりたいと思っています。 特に知財には興味があるので、知的財産管理技能士や弁理士の資格をとることは大いに検討すべきです。
さらに欲を言えば、資格に限らず、プログラミングや数学の勉強も今まで以上に進めていきたいです。 特にWebサービスをスクラッチから実装したことがないので、ぜひ挑戦してみたいです。
資格にせよ勉強にせよ、あまり手広くやると時間の無駄に終わることは明らかです。 これを機に一度ロードマップを作ってみるのもよいかもしれません。</p></div><footer class=entry-footer><span title='2016-12-26 00:00:00 +0900 +0900'>December 26, 2016</span></footer><a class=entry-link aria-label="post link to 資格取得と人生設計" href=https://inody.github.io/posts/license-life/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>簿記3級に受かりました</h2></header><div class=entry-content><p>就職を春に控え、一般常識で欠けている知識を補うために受験した簿記検定3級。 本番で解答用紙の下書きを消し忘れるという手痛いミスをしてしまいましたが、本日結果を確認すると、しっかり点が加算されていました。 参考書として使ったのは、TAC出版のスッキリわかる 日商簿記3級 第7版 [テキスト&問題集]です。 全体的にコンパクトにまとまっており、無駄なく勉強することができました。
つぎはファイナンシャルプランナー検定を受験したいと思います。
スッキリわかる 日商簿記3級 第7版 [テキスト&問題集] (スッキリわかるシリーズ)posted with amazlet at 16.12.06滝澤 ななみ TAC出版 (2016-02-26)
売り上げランキング: 292
Amazon.co.jpで詳細を見る</p></div><footer class=entry-footer><span title='2016-12-06 00:00:00 +0900 +0900'>December 6, 2016</span></footer><a class=entry-link aria-label="post link to 簿記3級に受かりました" href=https://inody.github.io/posts/bookkeeping/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LaTeXで図を作成するときにおすすめの方法</h2></header><div class=entry-content><p>研究者の皆さんは，論文を作成するときにIllustratorなどのベクターイメージ編集ソフトを使っていることと存じます． しかしながら，こうしたソフトは一般に有償であり，学生には手が届かないもの． 中にはInkscapeなどのフリーソフトもあるため，そちらを使っている方もいるかもしれません（僕も少し前までこの方法でした）． 今回僕が紹介する手法は，皆さんおなじみのPowerPointやKeynoteなどのプレゼンテーションソフトを使う方法です．
本手法には，
ほとんどどのPCにもビルドインされているプレゼンソフトを使って作図できる（もちろんベクター画像として） 作成した図をそのままプレゼンの素材として流用できる プレゼンソフトの拡張機能を用いて，LaTeXコードで書かれた数式を自由に挿入・変更できる などのメリットがあります．
さて，本題の方法ですが，至ってシンプルです． 今回はPowerPointで説明します．
PowerPointを起動し，最もシンプルな白背景のテンプレートから新規ファイルを作成します
「デザイン」タブの「スライドのサイズ」から，スライドの縦横比を描きたい図に合わせて望ましいものに変更します
白紙のスライドに，図形ツールなどを使って図を作成します
新しい図は，スライドを改めて作成します
図を全て描き終わったら，「ファイル」からPDFとしてエクスポートします
LaTeXのソースコードで図を読み込むとき
\begin{figure}[t] \centering \includegraphics[page=1,width=60mm]{figure.pdf} \caption{An example. } \end{figure}
というように，page=のオプションを用いることで，表示したい図に対応するページ番号を指定します
LaTeXコードをコンパイルします
…という感じです．
この方法ですと，作成した図を一つのPDFファイルにまとめることができ，ディレクトリがすっきりするのも嬉しいポイントです． ただ，論文に挿入する図ごとに縦横比が大きく異なる際は，別の.pptxファイルを用意しなければいけませんので，注意が必要です．
また，PowerPointの場合，IquanaTeXというマクロを使えば，任意のLaTeXコードをベクター画像として生成・編集できますし，Keynoteの場合，MacTeXに最初から付属しているLaTeXitを用いれば自由に数式を挿入できます．
また，もしMatlabの図を使いたい場合，Matlabのプロットが表示されているウィンドウから「編集」→「Figureのコピー」を選んで，そのまま貼り付ければちゃんとベクター画像として処理してくれます．
この方法を編み出してから，めんどくさい作図にかかる時間を短縮することができるようになりました． 読者の皆さんにも自信をもっておすすめします．</p></div><footer class=entry-footer><span title='2016-09-30 00:00:00 +0900 +0900'>September 30, 2016</span></footer><a class=entry-link aria-label="post link to LaTeXで図を作成するときにおすすめの方法" href=https://inody.github.io/posts/latex-figure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>モーパッサン『女の一生』を読みました</h2></header><div class=entry-content><p>二人の人間が、本当に魂の底まで、思いの奥底までひとつになることはできないのだと、ジャンヌは初めて思った。肩を並べて歩き、ときに抱き合うことはあっても、ひとつに溶け合うことはなく、心の底では誰もが生涯一人ぼっちなのだと。
モーパッサン『女の一生』光文社古典新訳文庫
光文社古典新訳文庫のシリーズが軒並みKindle Unlimitedの対象になっていたので、読書欲が際限なく刺激される今日この頃。 最近は新書を読むことが多かったので、久しぶりに読む小説は新鮮に感じられました。
以下あらすじ：
主人公のジャンヌは、貴族の一人娘として生まれ、幼い頃から修道院で何の汚れも知らぬまま大人になる。 ある日出会った美男の子爵ジュリアンからの求婚を受けるジャンヌ。 幸福の絶頂にいる彼女だが、その後の人生は要約すると転落の一言。
ある日、以前から様子がおかしい召使のロザリが突然倒れ、子供を出産する。 誰の子か問いただしても、口を閉ざすロザリ。 神父の前で懺悔させると、ようやく重い口を開き、父親がジュリアンであることを告げる。 ジャンヌの父親はこれに激怒するが、神父に誰にでもある間違いにすぎないと説得され、若いころの自分にも心当たりのあった父親はこれを許す。
ジャンヌにはその頃既に妊娠していた。 夫への愛は完全に消え失せた彼女だが、生まれる子供には出来る限りの愛情を尽くすことを誓う。
ジャンヌは父親とともに生まれてきた息子ポールを溺愛する。 ジュリアンはその頃、近所に住む貴族のジルベルト夫人と不倫を始めるが、既に夫に失望しているジャンヌは、苦悩の末見てみぬ振りをすることを選ぶ。 しかしながら夫人の夫に事がバレた二人は、密会中に夫に殺される。
一時期は愛した夫を失ったジャンヌは、母親にも先立たれたたジャンヌの父親とともに、ますます過剰なまでの愛をポールに注ぐ。 結果落ちこぼれとして育ったポールは、学校に入学後も落第しつづけ、女と駆け落ちしてロンドンに行方を眩ます。 彼は事業を起こして失敗し、多額の借金を背負い、手紙でジャンヌに無心する。 ジャンヌは財産を全て失い、家を手放すことになり、ジャンヌの父もその心労から脳溢血で亡くなる。
ポールは恋人に子供を産ませるが、産褥で亡くなる。 そのことを知ったジャンヌは、召使に引き取らせた孫娘を胸に抱き、終劇。
：以上あらすじ
あらすじを書くだけで、鬱々としてきます。 あまりにも善良で無知、人々の悪意を知らずに育ったジャンヌは、数々の試練を自ら切り拓くことなく、ただ周囲の流れに身を任せます。 結果悲劇的とも言える人生が待ち構えているわけなのですが、果たしてそれは彼女の怠惰に起因するものなのでしょうか。 筆者はそのよう因果関係を匂わせる文章を一切記述せず、起こった事実をありのまま精密に描写します。 つまり物語に教訓はなく、解釈は読者の方に委ねられていると捉えるべきでしょう。 冷徹なまでの写実的描写は、読んでいて映画を観ている錯覚を引き起こしました。
ぐんぐん進む馬車に乗っていること、窓の外の物悲しい風景を眺めること、そして降りしきる雨にもかかわらず、自分は濡れない場所にいること。ジャンヌはそれだけで嬉しかった。
モーパッサン『女の一生』光文社古典新訳文庫
原題は“Une vie”。 どこにも「女の」とは書いておらず、「ある人生」と訳すのが適当そうです。 筆者がやりたかったことは、人生とはこういうものだということを普遍的に描くことだったのかもしれません。</p></div><footer class=entry-footer><span title='2016-08-26 00:00:00 +0900 +0900'>August 26, 2016</span></footer><a class=entry-link aria-label="post link to モーパッサン『女の一生』を読みました" href=https://inody.github.io/posts/read-maupassant/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://inody.github.io/posts/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://inody.github.io/posts/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://inody.github.io/>inosite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>